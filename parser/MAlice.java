/* Generated By:JavaCC: Do not edit this line. MAlice.java */
package parser;

import java.util.LinkedList;
import ast.*;
import ast.basic.*;
import ast.expressions.*;
import ast.functions.*;
import ast.statements.*;

public class MAlice implements MAliceConstants {
   public static void main(String args[]) throws ParseException {
      MAlice parser = new MAlice(System.in);
      parser.parseProgram();
   }

   static final public ProgramNode parseProgram() throws ParseException {
      MainNode mainNode;
      FunctionNode functionBuffer;
      LinkedList<FunctionNode> functions = new LinkedList<FunctionNode>();
      mainNode = parseMain();
      label_1: while (true) {
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case THEROOM:
         case THELOOKINGGLASS:
            ;
            break;
         default:
            jj_la1[0] = jj_gen;
            break label_1;
         }
         functionBuffer = parseFunction();
         functions.add(functionBuffer);
      }
      {
         if (true)
            return new ProgramNode(mainNode, functions);
      }
      throw new Error("Missing return statement in function");
   }

   /*
    * <Function> -> <ROOM_FUNCTION> | <LOOKING_GLASS> <ROOM_FUNCTION> ->
    * <F_ROOM> STRING (<ARGUMENT-LIST>) <F_CONTAINED> <RETURN_TYPE> <LOS>
    * <RETURN> <LOOKING_GLASS> -> <F_LOOKING> STRING <F_CHANGED> <RETURN_TYPE>
    * <LOS>
    */
   static final public FunctionNode parseFunction() throws ParseException {
      FunctionNode function;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case THEROOM:
         function = parseRoom();
         break;
      case THELOOKINGGLASS:
         function = parseLookingGlass();
         break;
      default:
         jj_la1[1] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      {
         if (true)
            return function;
      }
      throw new Error("Missing return statement in function");
   }

   static final public RoomFunctionNode parseRoom() throws ParseException {
      Token t;
      LinkedList<ArgumentDefinitionNode> arguments = new LinkedList<ArgumentDefinitionNode>();
      Type returnType;
      StatementListNode functionBody;
      jj_consume_token(THEROOM);
      t = jj_consume_token(IDENTIFIER);
      arguments = parseArguments();
      jj_consume_token(CONTAINEDA);
      returnType = parseType();
      functionBody = parseListOfStatements();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case RETURN:
         parseReturn();
         break;
      default:
         jj_la1[2] = jj_gen;
         ;
      }
      // TODO What about the [parseReturn()]?
      {
         if (true)
            return new RoomFunctionNode(t.image, arguments, returnType,
                  functionBody);
      }
      throw new Error("Missing return statement in function");
   }

   static final public FoundNode parseReturn() throws ParseException {
      ExpressionNode expression;
      jj_consume_token(RETURN);
      expression = parseExpression();
      {
         if (true)
            return new FoundNode(expression);
      }
      throw new Error("Missing return statement in function");
   }

   static final public LookingGlassFunctionNode parseLookingGlass()
         throws ParseException {
      Token t;
      Type argType;
      StatementListNode functionBody;
      jj_consume_token(THELOOKINGGLASS);
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(CHANGEDA);
      argType = parseType();
      functionBody = parseListOfStatements();
      {
         if (true)
            return new LookingGlassFunctionNode(t.image, argType, functionBody);
      }
      throw new Error("Missing return statement in function");
   }

   /*
    * <Arguments>
    */
   static final public LinkedList<ArgumentDefinitionNode> parseArguments()
         throws ParseException {
      LinkedList<ArgumentDefinitionNode> arguments = new LinkedList<ArgumentDefinitionNode>();
      boolean isSpider = false;
      Type argType;
      ArgumentDefinitionNode argBuffer;
      Token t;
      jj_consume_token(LEFTBRACKET);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case T_NUMBER:
      case T_LETTER:
      case T_STRING:
      case SPIDER:
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case SPIDER:
            jj_consume_token(SPIDER);
            isSpider = true;
            break;
         default:
            jj_la1[3] = jj_gen;
            ;
         }
         argType = parseType();
         t = jj_consume_token(IDENTIFIER);
         arguments.add(new ArgumentDefinitionNode(argType, t.image, isSpider));
         isSpider = false;
         label_2: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case COMMA:
               ;
               break;
            default:
               jj_la1[4] = jj_gen;
               break label_2;
            }
            jj_consume_token(COMMA);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SPIDER:
               jj_consume_token(SPIDER);
               isSpider = true;
               break;
            default:
               jj_la1[5] = jj_gen;
               ;
            }
            argType = parseType();
            t = jj_consume_token(IDENTIFIER);
            arguments
                  .add(new ArgumentDefinitionNode(argType, t.image, isSpider));
            isSpider = false;
         }
         break;
      default:
         jj_la1[6] = jj_gen;
         ;
      }
      jj_consume_token(RIGHTBRACKET);
      {
         if (true)
            return arguments;
      }
      throw new Error("Missing return statement in function");
   }

   static final public Type parseType() throws ParseException {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case T_NUMBER:
         jj_consume_token(T_NUMBER);
         {
            if (true)
               return Type.NUMBER;
         }
         break;
      case T_LETTER:
         jj_consume_token(T_LETTER);
         {
            if (true)
               return Type.LETTER;
         }
         break;
      case T_STRING:
         jj_consume_token(T_STRING);
         {
            if (true)
               return Type.STRING;
         }
         {
            if (true)
               return null;
         }
         break;
      default:
         jj_la1[7] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static final public MainNode parseMain() throws ParseException {
      StatementListNode statementsNode;
      statementsNode = parseListOfStatements();
      {
         if (true)
            return new MainNode(statementsNode);
      }
      throw new Error("Missing return statement in function");
   }

   static final public StatementListNode parseListOfStatements()
         throws ParseException {
      StatementNode statementNode;
      StatementListNode rest = null;
      // empty program??
      statementNode = parseStatement();
      parseEnd();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WHATWAS:
      case LEFTBRACKET:
      case EXCL:
      case RETURN:
      case EVENTUALLY:
      case EITHER:
      case PERHAPS:
      case BIT_COMP:
      case MINUS:
      case INT:
      case IDENTIFIER:
      case STRING_LITERAL:
         rest = parseListOfStatements();
         break;
      default:
         jj_la1[8] = jj_gen;
         ;
      }
      {
         if (true)
            return new StatementListNode(statementNode, rest);
      }
      throw new Error("Missing return statement in function");
   }

   /*
    * End - > "," | "and" | "." | "but" | "then" | "?"
    */
   static final public void parseEnd() throws ParseException {
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case COMMA:
         jj_consume_token(COMMA);
         break;
      case AND:
         jj_consume_token(AND);
         break;
      case DOT:
         jj_consume_token(DOT);
         break;
      case BUT:
         jj_consume_token(BUT);
         break;
      case THEN:
         jj_consume_token(THEN);
         break;
      case QMARK:
         jj_consume_token(QMARK);
         break;
      default:
         jj_la1[9] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
   }

   static final public StatementNode parseStatement() throws ParseException {
      Token t;
      StatementNode result;
      IdentifierNode identifier;
      BasicIdentifierNode basicIdentifier;
      LookingGlassCallNode lookingCall;
      RoomCallNode roomCall;
      NonCharExpressionNode nonCharExpression;
      if (jj_2_1(2)) {
         t = jj_consume_token(IDENTIFIER);
         identifier = new BasicIdentifierNode(t.image);
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case WASA:
         case HAD:
            result = parseDeclaration((BasicIdentifierNode) identifier);
            {
               if (true)
                  return result;
            }
            break;
         case BECAME:
         case SPOKE:
         case ARRINDEX:
         case DRANK:
         case ATE:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ARRINDEX:
               identifier = parseArray((BasicIdentifierNode) identifier);
               break;
            default:
               jj_la1[10] = jj_gen;
               ;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case BECAME:
               result = parseAssignment(identifier);
               {
                  if (true)
                     return result;
               }
               break;
            case SPOKE:
               jj_consume_token(SPOKE);
               {
                  if (true)
                     return new SaidSpokeNode(identifier);
               }
               break;
            case DRANK:
               jj_consume_token(DRANK);
               {
                  if (true)
                     return new DrankNode(identifier);
               }
               break;
            case ATE:
               jj_consume_token(ATE);
               {
                  if (true)
                     return new AteNode(identifier);
               }
               break;
            default:
               jj_la1[11] = jj_gen;
               jj_consume_token(-1);
               throw new ParseException();
            }
            break;
         case WENTTHROUGH:
            // no arrays
            lookingCall = parseLookingGlassCall(identifier);
            {
               if (true)
                  return lookingCall;
            }
            break;
         case LEFTBRACKET:
            // room function call
            roomCall = parseRoomFunctionCall(t);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SPOKE:
               jj_consume_token(SPOKE);
               {
                  if (true)
                     return new SaidSpokeNode(roomCall);
               }
               break;
            default:
               jj_la1[12] = jj_gen;
               ;
            }
            {
               if (true)
                  return roomCall;
            }
            break;
         default:
            jj_la1[13] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
      } else {
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case STRING_LITERAL:
            t = jj_consume_token(STRING_LITERAL);
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SPOKE:
               jj_consume_token(SPOKE);
               {
                  if (true)
                     return new SaidSpokeNode(new StringLiteralNode(t.image));
               }
               break;
            case SAID:
               jj_consume_token(SAID);
               {
                  if (true)
                     return new SaidSpokeNode(new StringLiteralNode(t.image));
               }
               break;
            default:
               jj_la1[14] = jj_gen;
               jj_consume_token(-1);
               throw new ParseException();
            }
            break;
         case LEFTBRACKET:
         case EXCL:
         case BIT_COMP:
         case MINUS:
         case INT:
         case IDENTIFIER:
            nonCharExpression = parseNonCharExpression();
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case SPOKE:
            case SAID:
               switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
               case SPOKE:
                  jj_consume_token(SPOKE);
                  {
                     if (true)
                        return new SaidSpokeNode(nonCharExpression);
                  }
                  break;
               case SAID:
                  jj_consume_token(SAID);
                  {
                     if (true)
                        return new SaidSpokeNode(nonCharExpression);
                  }
                  break;
               default:
                  jj_la1[15] = jj_gen;
                  jj_consume_token(-1);
                  throw new ParseException();
               }
               break;
            default:
               jj_la1[16] = jj_gen;
               ;
            }
            {
               if (true)
                  return nonCharExpression;
            }
            break;
         case EVENTUALLY:
            result = parseEventually();
            {
               if (true)
                  return result;
            }
            break;
         case PERHAPS:
            result = parsePerhaps();
            {
               if (true)
                  return result;
            }
            break;
         case EITHER:
            result = parseEither();
            {
               if (true)
                  return result;
            }
            break;
         case RETURN:
            result = parseReturn();
            {
               if (true)
                  return result;
            }
            break;
         case WHATWAS:
            result = parseWhatWas();
            {
               if (true)
                  return result;
            }
            break;
         default:
            jj_la1[17] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
      }
      throw new Error("Missing return statement in function");
   }

   static final public WhatWasNode parseWhatWas() throws ParseException {
      IdentifierNode identifier;
      Token t;
      jj_consume_token(WHATWAS);
      t = jj_consume_token(IDENTIFIER);
      identifier = new BasicIdentifierNode(t.image);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case ARRINDEX:
         identifier = parseArray((BasicIdentifierNode) identifier);
         break;
      default:
         jj_la1[18] = jj_gen;
         ;
      }
      {
         if (true)
            return new WhatWasNode(identifier);
      }
      throw new Error("Missing return statement in function");
   }

   static final public DeclareNode parseDeclaration(
         BasicIdentifierNode identifier) throws ParseException {
      Type declaredType;
      NumericalExpressionNode arraySize;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WASA:
         jj_consume_token(WASA);
         declaredType = parseType();
         {
            if (true)
               return new DeclareBasicNode(identifier, declaredType);
         }
         break;
      case HAD:
         jj_consume_token(HAD);
         arraySize = parseNumericalExpression();
         declaredType = parseType();
         {
            if (true)
               return new DeclareArrayNode(identifier, arraySize, declaredType);
         }
         break;
      default:
         jj_la1[19] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static final public ArrayElementIdentifierNode parseArray(
         BasicIdentifierNode arrayName) throws ParseException {
      NumericalExpressionNode index;
      jj_consume_token(ARRINDEX);
      index = parseNumericalExpression();
      jj_consume_token(PIECE);
      {
         if (true)
            return new ArrayElementIdentifierNode(arrayName, index);
      }
      throw new Error("Missing return statement in function");
   }

   static final public AssignNode parseAssignment(IdentifierNode identifier)
         throws ParseException {
      ExpressionNode expression;
      jj_consume_token(BECAME);
      expression = parseExpression();
      {
         if (true)
            return new AssignNode(identifier, expression);
      }
      throw new Error("Missing return statement in function");
   }

   static final public RoomCallNode parseRoomFunctionCall(Token identifier)
         throws ParseException {
      LinkedList<ParameterNode> params = new LinkedList<ParameterNode>();
      ParameterNode p;
      jj_consume_token(LEFTBRACKET);
      p = parseParameter();
      params.add(p);
      label_3: while (true) {
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case COMMA:
         case DOT:
         case AND:
         case BUT:
         case THEN:
         case QMARK:
            ;
            break;
         default:
            jj_la1[20] = jj_gen;
            break label_3;
         }
         parseEnd();
         p = parseParameter();
         params.add(p);
      }
      jj_consume_token(RIGHTBRACKET);
      {
         if (true)
            return new RoomCallNode(identifier.image, params);
      }
      throw new Error("Missing return statement in function");
   }

   static final public LookingGlassCallNode parseLookingGlassCall(
         IdentifierNode identifier) throws ParseException {
      Token t;
      jj_consume_token(WENTTHROUGH);
      t = jj_consume_token(IDENTIFIER);
      {
         if (true)
            return new LookingGlassCallNode(identifier, t.image);
      }
      throw new Error("Missing return statement in function");
   }

   // FUNCTION CALLS
   static final public ParameterNode parseParameter() throws ParseException {
      NonCharExpressionNode nonCharExpression;
      Token t;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LEFTBRACKET:
      case EXCL:
      case BIT_COMP:
      case MINUS:
      case INT:
      case IDENTIFIER:
         nonCharExpression = parseNonCharExpression();
         {
            if (true)
               return new ParameterNode(nonCharExpression);
         }
         break;
      case STRING_LITERAL:
         t = jj_consume_token(STRING_LITERAL);
         {
            if (true)
               return new ParameterNode(new StringLiteralNode(t.image));
         }
         break;
      case LITERALCHAR:
         t = jj_consume_token(LITERALCHAR);
         {
            if (true)
               return new ParameterNode(new CharacterLiteralNode(t.image));
         }
         break;
      default:
         jj_la1[21] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   // LOOPS
   static final public EventuallyNode parseEventually() throws ParseException {
      NonCharExpressionNode condition;
      StatementListNode body;
      jj_consume_token(EVENTUALLY);
      jj_consume_token(LEFTBRACKET);
      condition = parseNonCharExpression();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(BECAUSE);
      body = parseListOfStatements();
      jj_consume_token(ENOUGH);
      {
         if (true)
            return new EventuallyNode(condition, body);
      }
      throw new Error("Missing return statement in function");
   }

   static final public PerhapsNode parsePerhaps() throws ParseException {
      NonCharExpressionNode condition;
      StatementListNode ifTrue;
      StatementListNode ifNot;
      ElseNode elseIfNode = null;
      PerhapsNode result;
      jj_consume_token(PERHAPS);
      jj_consume_token(LEFTBRACKET);
      condition = parseNonCharExpression();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(SO);
      ifTrue = parseListOfStatements();
      result = new PerhapsNode(condition, ifTrue, null);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case OR:
         jj_consume_token(OR);
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case MAYBE:
            elseIfNode = parseMaybe();
            result = new PerhapsNode(condition, ifTrue, elseIfNode);
            break;
         case WHATWAS:
         case LEFTBRACKET:
         case EXCL:
         case RETURN:
         case EVENTUALLY:
         case EITHER:
         case PERHAPS:
         case BIT_COMP:
         case MINUS:
         case INT:
         case IDENTIFIER:
         case STRING_LITERAL:
            ifNot = parseListOfStatements();
            result = new PerhapsNode(condition, ifTrue, ifNot);
            break;
         default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
         break;
      default:
         jj_la1[23] = jj_gen;
         ;
      }
      jj_consume_token(UNSURE);
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case WHICH:
         jj_consume_token(WHICH);
         break;
      default:
         jj_la1[24] = jj_gen;
         ;
      }
      {
         if (true)
            return result;
      }
      throw new Error("Missing return statement in function");
   }

   static final public ElseNode parseMaybe() throws ParseException {
      ElseNode elseNode = null;
      StatementListNode list;
      NonCharExpressionNode elseIfCondition;
      jj_consume_token(MAYBE);
      jj_consume_token(LEFTBRACKET);
      elseIfCondition = parseNonCharExpression();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(SO);
      list = parseListOfStatements();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case OR:
         jj_consume_token(OR);
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case MAYBE:
            elseNode = parseMaybe();
            break;
         case WHATWAS:
         case LEFTBRACKET:
         case EXCL:
         case RETURN:
         case EVENTUALLY:
         case EITHER:
         case PERHAPS:
         case BIT_COMP:
         case MINUS:
         case INT:
         case IDENTIFIER:
         case STRING_LITERAL:
            elseNode = parseListOfStatements();
            break;
         default:
            jj_la1[25] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
         break;
      default:
         jj_la1[26] = jj_gen;
         ;
      }
      {
         if (true)
            return new PerhapsNode(elseIfCondition, list, elseNode);
      }
      throw new Error("Missing return statement in function");
   }

   static final public EitherNode parseEither() throws ParseException {
      NonCharExpressionNode condition;
      StatementListNode ifTrue;
      StatementListNode ifFalse;
      jj_consume_token(EITHER);
      jj_consume_token(LEFTBRACKET);
      condition = parseNonCharExpression();
      jj_consume_token(RIGHTBRACKET);
      jj_consume_token(SO);
      ifTrue = parseListOfStatements();
      jj_consume_token(OR);
      ifFalse = parseListOfStatements();
      jj_consume_token(UNSURE);
      jj_consume_token(WHICH);
      {
         if (true)
            return new EitherNode(condition, ifTrue, ifFalse);
      }
      throw new Error("Missing return statement in function");
   }

   // EXPRESSIONS START HERE
   static final public ExpressionNode parseExpression() throws ParseException {
      Token t;
      NonCharExpressionNode nonCharExpression;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LITERALCHAR:
         t = jj_consume_token(LITERALCHAR);
         {
            if (true)
               return new CharacterLiteralNode(t.image);
         }
         break;
      case STRING_LITERAL:
         t = jj_consume_token(STRING_LITERAL);
         {
            if (true)
               return new StringLiteralNode(t.image);
         }
         break;
      case LEFTBRACKET:
      case EXCL:
      case BIT_COMP:
      case MINUS:
      case INT:
      case IDENTIFIER:
         nonCharExpression = parseNonCharExpression();
         {
            if (true)
               return nonCharExpression;
         }
         break;
      default:
         jj_la1[27] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static final public NonCharExpressionNode parseNonCharExpression()
         throws ParseException {
      NonCharExpressionNode left;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LEFTBRACKET:
      case BIT_COMP:
      case MINUS:
      case INT:
      case IDENTIFIER:
         left = parseNonCharExpression2();
         left = parseNonCharExpression1a(left);
         {
            if (true)
               return left;
         }
         break;
      case EXCL:
         jj_consume_token(EXCL);
         jj_consume_token(LEFTBRACKET);
         left = parseNonCharExpression();
         jj_consume_token(RIGHTBRACKET);
         {
            if (true)
               return new NotBooleanNode(left);
         }
         break;
      default:
         jj_la1[28] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static final public NonCharExpressionNode parseNonCharExpression1a(
         NonCharExpressionNode left) throws ParseException {
      NonCharExpressionNode right;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BOOL_OR:
         jj_consume_token(BOOL_OR);
         right = parseNonCharExpression2();
         right = parseNonCharExpression1a(new BoolOrExpressionNode(left, right));
         {
            if (true)
               return right;
         }
         break;
      default:
         jj_la1[29] = jj_gen;
         ;
      }
      {
         if (true)
            return left;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NonCharExpressionNode parseNonCharExpression2()
         throws ParseException {
      NonCharExpressionNode left;
      left = parseNonCharExpression3();
      left = parseNonCharExpression2a(left);
      {
         if (true)
            return left;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NonCharExpressionNode parseNonCharExpression2a(
         NonCharExpressionNode left) throws ParseException {
      NonCharExpressionNode right;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BOOL_AND:
         jj_consume_token(BOOL_AND);
         right = parseNonCharExpression3();
         right = parseNonCharExpression2a(new BoolAndExpressionNode(left, right));
         {
            if (true)
               return right;
         }
         break;
      default:
         jj_la1[30] = jj_gen;
         ;
      }
      {
         if (true)
            return left;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NonCharExpressionNode parseNonCharExpression3()
         throws ParseException {
      NumericalExpressionNode n1;
      BoolExpressionNode comparisonNode;
      n1 = parseNumericalExpression();
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BOOL_GT:
      case BOOL_GTE:
      case BOOL_LT:
      case BOOL_LTE:
      case BOOL_EQ:
      case BOOL_NOTEQ:
         comparisonNode = parseEqOp(n1);
         {
            if (true)
               return comparisonNode;
         }
         break;
      default:
         jj_la1[31] = jj_gen;
         ;
      }
      {
         if (true)
            return n1;
      }
      throw new Error("Missing return statement in function");
   }

   static final public ComparisonNode parseEqOp(NumericalExpressionNode left)
         throws ParseException {
      NumericalExpressionNode right;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BOOL_GT:
         jj_consume_token(BOOL_GT);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonGTNode(left, right);
         }
         break;
      case BOOL_GTE:
         jj_consume_token(BOOL_GTE);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonGTENode(left, right);
         }
         break;
      case BOOL_LT:
         jj_consume_token(BOOL_LT);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonLTNode(left, right);
         }
         break;
      case BOOL_LTE:
         jj_consume_token(BOOL_LTE);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonLTENode(left, right);
         }
         break;
      case BOOL_EQ:
         jj_consume_token(BOOL_EQ);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonEQNode(left, right);
         }
         break;
      case BOOL_NOTEQ:
         jj_consume_token(BOOL_NOTEQ);
         right = parseNumericalExpression();
         {
            if (true)
               return new ComparisonNOTEQNode(left, right);
         }
         break;
      default:
         jj_la1[32] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   // NUMERICAL EXPRESSIONS
   static final public NumericalExpressionNode parseNumericalExpression()
         throws ParseException {
      NumericalExpressionNode n;
      n = parseNumericalExpression2();
      n = parseNumericalExpressiona(n);
      {
         if (true)
            return n;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpressiona(
         NumericalExpressionNode prev) throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BIT_OR:
         jj_consume_token(BIT_OR);
         n = parseNumericalExpression2();
         n = parseNumericalExpressiona(new BitOrExpressionNode(prev, n));
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[33] = jj_gen;
         ;
      }
      {
         if (true)
            return prev;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression2()
         throws ParseException {
      NumericalExpressionNode n;
      n = parseNumericalExpression3();
      n = parseNumericalExpression2a(n);
      {
         if (true)
            return n;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression2a(
         NumericalExpressionNode prev) throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BIT_XOR:
         jj_consume_token(BIT_XOR);
         n = parseNumericalExpression3();
         n = parseNumericalExpression2a(new BitXorExpressionNode(prev, n));
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[34] = jj_gen;
         ;
      }
      {
         if (true)
            return prev;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression3()
         throws ParseException {
      NumericalExpressionNode n;
      n = parseNumericalExpression4();
      n = parseNumericalExpression3a(n);
      {
         if (true)
            return n;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression3a(
         NumericalExpressionNode prev) throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BIT_AND:
         jj_consume_token(BIT_AND);
         n = parseNumericalExpression4();
         n = parseNumericalExpression4a(new BitAndExpressionNode(prev, n));
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[35] = jj_gen;
         ;
      }
      {
         if (true)
            return prev;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression4()
         throws ParseException {
      NumericalExpressionNode n;
      n = parseNumericalExpression5();
      n = parseNumericalExpression4a(n);
      {
         if (true)
            return n;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression4a(
         NumericalExpressionNode prev) throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case PLUS:
      case MINUS:
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case PLUS:
            jj_consume_token(PLUS);
            n = parseNumericalExpression5();
            n = parseNumericalExpression4a(new PlusExpressionNode(prev, n));
            break;
         case MINUS:
            jj_consume_token(MINUS);
            n = parseNumericalExpression5();
            n = parseNumericalExpression4a(new MinusExpressionNode(prev, n));
            break;
         default:
            jj_la1[36] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[37] = jj_gen;
         ;
      }
      {
         if (true)
            return prev;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression5()
         throws ParseException {
      NumericalExpressionNode n;
      n = parseNumericalExpression6();
      n = parseNumericalExpression5a(n);
      {
         if (true)
            return n;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression5a(
         NumericalExpressionNode prev) throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case MULT:
      case DIV:
      case MOD:
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case MULT:
            jj_consume_token(MULT);
            n = parseNumericalExpression6();
            n = parseNumericalExpression5a(new MultExpressionNode(prev, n));
            break;
         case DIV:
            jj_consume_token(DIV);
            n = parseNumericalExpression6();
            n = parseNumericalExpression5a(new DivExpressionNode(prev, n));
            break;
         case MOD:
            jj_consume_token(MOD);
            n = parseNumericalExpression6();
            n = parseNumericalExpression5a(new ModExpressionNode(prev, n));
            break;
         default:
            jj_la1[38] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
         }
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[39] = jj_gen;
         ;
      }
      {
         if (true)
            return prev;
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression6()
         throws ParseException {
      NumericalExpressionNode n;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case BIT_COMP:
         jj_consume_token(BIT_COMP);
         n = parseNumericalExpression();
         {
            if (true)
               return new BitCompNode(n);
         }
         break;
      case MINUS:
         jj_consume_token(MINUS);
         n = parseNumericalExpression();
         {
            if (true)
               return new NegateIntegerNode(n);
         }
         break;
      case LEFTBRACKET:
      case INT:
      case IDENTIFIER:
         n = parseNumericalExpression7();
         {
            if (true)
               return n;
         }
         break;
      default:
         jj_la1[40] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static final public NumericalExpressionNode parseNumericalExpression7()
         throws ParseException {
      NumericalExpressionNode n;
      BasicIdentifierNode basic;
      RoomCallNode room;
      ArrayElementIdentifierNode arrayIdent;
      Token t;
      switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
      case LEFTBRACKET:
         jj_consume_token(LEFTBRACKET);
         n = parseNumericalExpression();
         jj_consume_token(RIGHTBRACKET);
         {
            if (true)
               return n;
         }
         break;
      case IDENTIFIER:
         t = jj_consume_token(IDENTIFIER);
         basic = new BasicIdentifierNode(t.image);
         switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
         case ARRINDEX:
         case LEFTBRACKET:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case ARRINDEX:
               arrayIdent = parseArray(basic);
               {
                  if (true)
                     return arrayIdent;
               }
               break;
            case LEFTBRACKET:
               room = parseRoomFunctionCall(t);
               {
                  if (true)
                     return room;
               }
               break;
            default:
               jj_la1[41] = jj_gen;
               jj_consume_token(-1);
               throw new ParseException();
            }
            break;
         default:
            jj_la1[42] = jj_gen;
            ;
         }
         {
            if (true)
               return basic;
         }
         break;
      case INT:
         t = jj_consume_token(INT);
         {
            if (true)
               return new IntegerLiteralNode(t.image);
         }
         break;
      default:
         jj_la1[43] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
      }
      throw new Error("Missing return statement in function");
   }

   static private boolean jj_2_1(int xla) {
      jj_la = xla;
      jj_lastpos = jj_scanpos = token;
      try {
         return !jj_3_1();
      } catch (LookaheadSuccess ls) {
         return true;
      } finally {
         jj_save(0, xla);
      }
   }

   static private boolean jj_3R_18() {
      if (jj_scan_token(ARRINDEX))
         return true;
      return false;
   }

   static private boolean jj_3R_15() {
      if (jj_scan_token(LEFTBRACKET))
         return true;
      return false;
   }

   static private boolean jj_3R_13() {
      if (jj_scan_token(ATE))
         return true;
      return false;
   }

   static private boolean jj_3R_5() {
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_9())
         jj_scanpos = xsp;
      xsp = jj_scanpos;
      if (jj_3R_10()) {
         jj_scanpos = xsp;
         if (jj_3R_11()) {
            jj_scanpos = xsp;
            if (jj_3R_12()) {
               jj_scanpos = xsp;
               if (jj_3R_13())
                  return true;
            }
         }
      }
      return false;
   }

   static private boolean jj_3R_14() {
      if (jj_scan_token(WENTTHROUGH))
         return true;
      return false;
   }

   static private boolean jj_3R_12() {
      if (jj_scan_token(DRANK))
         return true;
      return false;
   }

   static private boolean jj_3R_4() {
      if (jj_3R_8())
         return true;
      return false;
   }

   static private boolean jj_3_1() {
      if (jj_scan_token(IDENTIFIER))
         return true;
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_4()) {
         jj_scanpos = xsp;
         if (jj_3R_5()) {
            jj_scanpos = xsp;
            if (jj_3R_6()) {
               jj_scanpos = xsp;
               if (jj_3R_7())
                  return true;
            }
         }
      }
      return false;
   }

   static private boolean jj_3R_10() {
      if (jj_3R_19())
         return true;
      return false;
   }

   static private boolean jj_3R_11() {
      if (jj_scan_token(SPOKE))
         return true;
      return false;
   }

   static private boolean jj_3R_7() {
      if (jj_3R_15())
         return true;
      return false;
   }

   static private boolean jj_3R_17() {
      if (jj_scan_token(HAD))
         return true;
      return false;
   }

   static private boolean jj_3R_19() {
      if (jj_scan_token(BECAME))
         return true;
      return false;
   }

   static private boolean jj_3R_9() {
      if (jj_3R_18())
         return true;
      return false;
   }

   static private boolean jj_3R_16() {
      if (jj_scan_token(WASA))
         return true;
      return false;
   }

   static private boolean jj_3R_8() {
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_16()) {
         jj_scanpos = xsp;
         if (jj_3R_17())
            return true;
      }
      return false;
   }

   static private boolean jj_3R_6() {
      if (jj_3R_14())
         return true;
      return false;
   }

   static private boolean jj_initialized_once = false;
   /** Generated Token Manager. */
   static public MAliceTokenManager token_source;
   static SimpleCharStream jj_input_stream;
   /** Current token. */
   static public Token token;
   /** Next token. */
   static public Token jj_nt;
   static private int jj_ntk;
   static private Token jj_scanpos, jj_lastpos;
   static private int jj_la;
   static private int jj_gen;
   static final private int[] jj_la1 = new int[44];
   static private int[] jj_la1_0;
   static private int[] jj_la1_1;
   static private int[] jj_la1_2;
   static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }

   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] { 0x50000000, 0x50000000, 0x8000000, 0x80000, 0x40,
            0x80000, 0x8e000, 0xe000, 0xd020000, 0x1007c0, 0x400000, 0x11000,
            0x10000, 0x1451800, 0x210000, 0x210000, 0x210000, 0xd020000,
            0x400000, 0x40800, 0x1007c0, 0x5000000, 0xd020000, 0x0, 0x0,
            0xd020000, 0x0, 0x5000000, 0x5000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x1000000, 0x1400000, 0x1400000,
            0x1000000, };
   }

   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0xc0020832, 0x0, 0x0, 0x3000, 0x0, 0x3001, 0x0, 0x0, 0x0,
            0xc0020832, 0x0, 0x0, 0x0, 0xc0020800, 0xc0020932, 0x80, 0x400,
            0xc0020932, 0x80, 0xc0020800, 0xc0020800, 0x8000, 0x4000,
            0x3f000000, 0x3f000000, 0x800000, 0x400000, 0x200000, 0x30000,
            0x30000, 0x1c0000, 0x1c0000, 0xc0020800, 0x0, 0x0, 0xc0000000, };
   }

   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0xc, 0x8,
            0x0, 0x0, 0x8, 0x0, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
   }

   static final private JJCalls[] jj_2_rtns = new JJCalls[1];
   static private boolean jj_rescan = false;
   static private int jj_gc = 0;

   /** Constructor with InputStream. */
   public MAlice(java.io.InputStream stream) {
      this(stream, null);
   }

   /** Constructor with InputStream and supplied encoding */
   public MAlice(java.io.InputStream stream, String encoding) {
      if (jj_initialized_once) {
         System.out
               .println("ERROR: Second call to constructor of static parser.  ");
         System.out
               .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
         System.out.println("       during parser generation.");
         throw new Error();
      }
      jj_initialized_once = true;
      try {
         jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
      } catch (java.io.UnsupportedEncodingException e) {
         throw new RuntimeException(e);
      }
      token_source = new MAliceTokenManager(jj_input_stream);
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   /** Reinitialise. */
   static public void ReInit(java.io.InputStream stream) {
      ReInit(stream, null);
   }

   /** Reinitialise. */
   static public void ReInit(java.io.InputStream stream, String encoding) {
      try {
         jj_input_stream.ReInit(stream, encoding, 1, 1);
      } catch (java.io.UnsupportedEncodingException e) {
         throw new RuntimeException(e);
      }
      token_source.ReInit(jj_input_stream);
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   /** Constructor. */
   public MAlice(java.io.Reader stream) {
      if (jj_initialized_once) {
         System.out
               .println("ERROR: Second call to constructor of static parser. ");
         System.out
               .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
         System.out.println("       during parser generation.");
         throw new Error();
      }
      jj_initialized_once = true;
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
      token_source = new MAliceTokenManager(jj_input_stream);
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   /** Reinitialise. */
   static public void ReInit(java.io.Reader stream) {
      jj_input_stream.ReInit(stream, 1, 1);
      token_source.ReInit(jj_input_stream);
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   /** Constructor with generated Token Manager. */
   public MAlice(MAliceTokenManager tm) {
      if (jj_initialized_once) {
         System.out
               .println("ERROR: Second call to constructor of static parser. ");
         System.out
               .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
         System.out.println("       during parser generation.");
         throw new Error();
      }
      jj_initialized_once = true;
      token_source = tm;
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   /** Reinitialise. */
   public void ReInit(MAliceTokenManager tm) {
      token_source = tm;
      token = new Token();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 44; i++)
         jj_la1[i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns[i] = new JJCalls();
   }

   static private Token jj_consume_token(int kind) throws ParseException {
      Token oldToken;
      if ((oldToken = token).next != null)
         token = token.next;
      else
         token = token.next = token_source.getNextToken();
      jj_ntk = -1;
      if (token.kind == kind) {
         jj_gen++;
         if (++jj_gc > 100) {
            jj_gc = 0;
            for (int i = 0; i < jj_2_rtns.length; i++) {
               JJCalls c = jj_2_rtns[i];
               while (c != null) {
                  if (c.gen < jj_gen)
                     c.first = null;
                  c = c.next;
               }
            }
         }
         return token;
      }
      token = oldToken;
      jj_kind = kind;
      throw generateParseException();
   }

   static private final class LookaheadSuccess extends java.lang.Error {
   }

   static final private LookaheadSuccess jj_ls = new LookaheadSuccess();

   static private boolean jj_scan_token(int kind) {
      if (jj_scanpos == jj_lastpos) {
         jj_la--;
         if (jj_scanpos.next == null) {
            jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
                  .getNextToken();
         } else {
            jj_lastpos = jj_scanpos = jj_scanpos.next;
         }
      } else {
         jj_scanpos = jj_scanpos.next;
      }
      if (jj_rescan) {
         int i = 0;
         Token tok = token;
         while (tok != null && tok != jj_scanpos) {
            i++;
            tok = tok.next;
         }
         if (tok != null)
            jj_add_error_token(kind, i);
      }
      if (jj_scanpos.kind != kind)
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         throw jj_ls;
      return false;
   }

   /** Get the next Token. */
   static final public Token getNextToken() {
      if (token.next != null)
         token = token.next;
      else
         token = token.next = token_source.getNextToken();
      jj_ntk = -1;
      jj_gen++;
      return token;
   }

   /** Get the specific Token. */
   static final public Token getToken(int index) {
      Token t = token;
      for (int i = 0; i < index; i++) {
         if (t.next != null)
            t = t.next;
         else
            t = t.next = token_source.getNextToken();
      }
      return t;
   }

   static private int jj_ntk() {
      if ((jj_nt = token.next) == null)
         return (jj_ntk = (token.next = token_source.getNextToken()).kind);
      else
         return (jj_ntk = jj_nt.kind);
   }

   static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
   static private int[] jj_expentry;
   static private int jj_kind = -1;
   static private int[] jj_lasttokens = new int[100];
   static private int jj_endpos;

   static private void jj_add_error_token(int kind, int pos) {
      if (pos >= 100)
         return;
      if (pos == jj_endpos + 1) {
         jj_lasttokens[jj_endpos++] = kind;
      } else if (jj_endpos != 0) {
         jj_expentry = new int[jj_endpos];
         for (int i = 0; i < jj_endpos; i++) {
            jj_expentry[i] = jj_lasttokens[i];
         }
         jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries
               .iterator(); it.hasNext();) {
            int[] oldentry = (int[]) (it.next());
            if (oldentry.length == jj_expentry.length) {
               for (int i = 0; i < jj_expentry.length; i++) {
                  if (oldentry[i] != jj_expentry[i]) {
                     continue jj_entries_loop;
                  }
               }
               jj_expentries.add(jj_expentry);
               break jj_entries_loop;
            }
         }
         if (pos != 0)
            jj_lasttokens[(jj_endpos = pos) - 1] = kind;
      }
   }

   /** Generate ParseException. */
   static public ParseException generateParseException() {
      jj_expentries.clear();
      boolean[] la1tokens = new boolean[68];
      if (jj_kind >= 0) {
         la1tokens[jj_kind] = true;
         jj_kind = -1;
      }
      for (int i = 0; i < 44; i++) {
         if (jj_la1[i] == jj_gen) {
            for (int j = 0; j < 32; j++) {
               if ((jj_la1_0[i] & (1 << j)) != 0) {
                  la1tokens[j] = true;
               }
               if ((jj_la1_1[i] & (1 << j)) != 0) {
                  la1tokens[32 + j] = true;
               }
               if ((jj_la1_2[i] & (1 << j)) != 0) {
                  la1tokens[64 + j] = true;
               }
            }
         }
      }
      for (int i = 0; i < 68; i++) {
         if (la1tokens[i]) {
            jj_expentry = new int[1];
            jj_expentry[0] = i;
            jj_expentries.add(jj_expentry);
         }
      }
      jj_endpos = 0;
      jj_rescan_token();
      jj_add_error_token(0, 0);
      int[][] exptokseq = new int[jj_expentries.size()][];
      for (int i = 0; i < jj_expentries.size(); i++) {
         exptokseq[i] = jj_expentries.get(i);
      }
      return new ParseException(token, exptokseq, tokenImage);
   }

   /** Enable tracing. */
   static final public void enable_tracing() {
   }

   /** Disable tracing. */
   static final public void disable_tracing() {
   }

   static private void jj_rescan_token() {
      jj_rescan = true;
      for (int i = 0; i < 1; i++) {
         try {
            JJCalls p = jj_2_rtns[i];
            do {
               if (p.gen > jj_gen) {
                  jj_la = p.arg;
                  jj_lastpos = jj_scanpos = p.first;
                  switch (i) {
                  case 0:
                     jj_3_1();
                     break;
                  }
               }
               p = p.next;
            } while (p != null);
         } catch (LookaheadSuccess ls) {
         }
      }
      jj_rescan = false;
   }

   static private void jj_save(int index, int xla) {
      JJCalls p = jj_2_rtns[index];
      while (p.gen > jj_gen) {
         if (p.next == null) {
            p = p.next = new JJCalls();
            break;
         }
         p = p.next;
      }
      p.gen = jj_gen + xla - jj_la;
      p.first = token;
      p.arg = xla;
   }

   static final class JJCalls {
      int gen;
      Token first;
      int arg;
      JJCalls next;
   }

}
